const express = require("express");
const { matchedData } = require("express-validator");
const router = express.Router();
const mysql = require("mysql");
const conection = require("../connection");
const { Tournament, TournamentPlayers, Team, TeamMember } = require("../models/models");
const { Op } = require("sequelize");

require("dotenv").config();
db = conection;

async function f_getPlayersInTournament(tournamentId) {
    const playersInTournament = await TournamentPlayers.findAll({
        where: {
            id: tournamentId,
        },
    });

    return playersInTournament
}

async function f_getTeamsInTournament(tourPlayerIds) {
    const teamsIDInTournament = await TeamMember.findAll({
        where: {
            id: tourPlayerIds,
        },
    });

    const teamIds = [];
    for (let i = 0; i < teamsIDInTournament.length; i++)
        teamIds.push(teamsIDInTournament[i].teamId);

    const teamsInTournament = await Team.findAll({
        where: {
            id: teamIds,
        },
    })

    return teamsInTournament
}

function generateTeamsPerGroup(teamsCount) {
    let numGroups = 2
    let minTeamsInGroup = Math.floor(teamsCount / numGroups)
    let maxTeamsInGroup = 5

    while ( minTeamsInGroup > maxTeamsInGroup) {
        numGroups += 1
        minTeamsInGroup = Math.floor(teamsCount / numGroups)
    }
    
    let groups = []
    let groupCounter = 0
    for(let i = 0; i<numGroups; i++){
        let teamsInGroup = minTeamsInGroup
        groupCounter += teamsInGroup
        groups.push(teamsInGroup)
    }
    
    let restoTeams = teamsCount % numGroups
    for(let i=0; i<groups.length; i++) {
        if(restoTeams != 0) {
            groups[i] += 1
            restoTeams -= 1
        }
    }

    return groups
}

// ROUND ROBIN SCHEDULE

function generateTeamsPerGroup(teamsCount) {
    let numGroups = 2
    let minTeamsInGroup = Math.floor(teamsCount / numGroups)
    let maxTeamsInGroup = 5

    while ( minTeamsInGroup > maxTeamsInGroup) {
        numGroups += 1
        minTeamsInGroup = Math.floor(teamsCount / numGroups)
    }
    
    let groups = []
    let groupCounter = 0
    for(let i = 0; i<numGroups; i++){
        let teamsInGroup = minTeamsInGroup
        groupCounter += teamsInGroup
        groups.push(teamsInGroup)
    }
    
    let restoTeams = teamsCount % numGroups
    for(let i=0; i<groups.length; i++) {
        if(restoTeams != 0) {
            groups[i] += 1
            restoTeams -= 1
        }
    }

    return groups
}

function ordenamientoAleatorio(a, b) { return 0.5 - Math.random() }

function generateGroups(teams) {
    let teamsCount = teams.length
    let groupsCount = generateTeamsPerGroup(teamsCount)
    teams.sort(ordenamientoAleatorio)
    
    let groups = []
    for(let i=0; i<groupsCount.length; i++) {
        groups[i] = []
        for(let j=0; j<groupsCount[i];j++)
            groups[i].push(teams.pop())
    }
    
    return groups
}

function generateMatchesImpar(group, numTeams, numJornadas) {
    let schedule = []
    
    for (let i=0; i<numJornadas; i++) {
        let matches = []
        
        for(let j=0; j<(numTeams/2); j++) {
            let match = [group[j], group[numTeams - 1 - j]]
            matches.push(match)
        }
        
        schedule.push(matches)
        const firstTeam = group.shift()
        group.push(firstTeam)
    }
    
    return schedule
}

function generateMatchesPar(group, numTeams, numJornadas) {
    let schedule = []
    
    for (let i=0; i<(numJornadas-1); i++) {
        let matches = []
        console.log(group)
        for(let j=0; j<(numTeams/2); j++) {
            let match = [group[j], group[numTeams - 1 - j]]
            matches.push(match)
        }
        
        schedule.push(matches)
        const firstTeam = group.shift()
        group.push(firstTeam)
    }
    
    return schedule
}

function generateMatchesInGroup(group) {
    let numTeams = group.length
    let numJornadas = numTeams
    let numMatchesPerJornada = Math.ceil(numTeams / 2)

    let schedule = numTeams % 2 == 0 
        ? generateMatchesPar(group, numTeams, numJornadas)
        : generateMatchesImpar(group, numTeams, numJornadas)
    
    console.log(schedule)
    return schedule
}

function generateTournament(tournamentId, tournamentTeams) {
    let groups = generateGroups(tournamentTeams)
    let matches = []
    
    for(let i=0; i<groups.length; i++) {
        console.log(`Grupo ${i+1}: ${groups[i]}`)
        matches.push(generateMatchesInGroup(groups[i]))
    }

    return matches;
}

// var equipos = ['Real Madrid', 'Barça', 'Atlético de Madrid', 'Sevilla', 'Betis', 'Cádiz', 'Valencia', 'Villareal', 'Osasuna', 'Real Sociedad', 'Celta', 'Athletic Bilbao', 'RCD Espanyol']

// generateTournament(1, equipos)

async function fixTeams() {

}

const getTeamsInTournament = async (req, res) => {
    const playersInTournament = f_getPlayersInTournament(tournamentId)

    const tourPlayerIds = [];
    for (let i = 0; i < playersInTournament.length; i++)
        tourPlayerIds.push(playersInTournament[i].userId);

    res.send(f_getTeamsInTournament(tourPlayerIds))
};

const getPlayersInTournament = async (req, res) => {
    res.send(f_getPlayersInTournament(req.body.tournamentId))
};

const generateTournament = async (req, res) => {
    const { tournamentId } = req.body;
    const tournamentInfo = await Tournament.findOne({ where: { id: tournamentId } })

    // Recopilar todos los equipos y jugadores disponibles en el torneo
    const playersInTournament = f_getPlayersInTournament(tournamentId)

    const tourPlayerIds = [];
    for (let i = 0; i < playersInTournament.length; i++)
        tourPlayerIds.push(playersInTournament[i].userId);

    const teamsInTournament = f_getTeamsInTournament(tourPlayerIds)
    let teamsNumber = teamsInTournament.length
    // si es modo equipos
    // asignación de partidos
    if (tournamentInfo.type == 1) {
        generateTournament(tournamentId, teamsInTournament)
    }
    // si es modo equipos y jugadores
    // ver jugadores sin equipo y asignarles a un equipo
    else if (tournamentInfo.type == 2) {
        fixTeams() // mete a jugadores sin equipo en equipos sin mucha gente o crea nuevos equipos si necesario
        generateTournament(tournamentId, teamsInTournament)   
    }
}

const createTournament = async (req, res) => {
    try {
        // Extract data from request body
        const { name, description, sport, date_start, date_end, min_teams, max_teams, max_players_team, rounds, type, privacity } = req.body;

        // Create tournament in database
        const [tournament, created] = await Tournament.findOrCreate({
            where: {
                name,
            },
            defaults: {
                name, description, sport, date_start, date_end, min_teams, max_teams, max_players_team, rounds, type, privacity
            },
        });

        if (!created)
            return res.status(409).json({ message: "Tournament already exists" });

        // Send response with success message
        res.status(201).json({ message: "Tournament created successfully" });
    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Internal server error" });
    }
};

const getTournaments = async (req, res) => {
    try {
        var data = "";
        data = await Tournament.findAll();
        res.send(data);
    } catch (err) {
        console.log(err); //Opcional
        handleHttpError(res, "ERROR_GET_TOURNAMENT"); //Si nos sirve el de por defecto que hemos establecido, no es necesario pasar el 403
    }
};

const suscribeTournament = async (req, res) => {
    
};

const getMyTournaments = async (req, res) => {
    try {
        var data = "";
        data = await TournamentPlayers.findAll({
            where: {
                UserId: req.user.id,
            },
        });

        const tournamentIds = [];
        for (let i = 0; i < data.length; i++)
            tournamentIds.push(data[i].tournamentIds);
        
        const relatedRecords = await Tournament.findAll({
            where: {
                id: tournamentIds,
            },
        });

        res.send(relatedRecords);
    } catch (err) {
        console.log(err);

        handleHttpError(res, "ERROR_GET_MY_TOURNAMENT");
    }
};


module.exports = { createTournament, getTournaments, suscribeTournament, getMyTournaments, generateTournament, getPlayersInTournament, getTeamsInTournament };

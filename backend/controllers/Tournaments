const express = require("express");
const { matchedData } = require("express-validator");
const router = express.Router();
const mysql = require("mysql");
const conection = require("../connection");
const { User, Tournament, Team, TournamentTeams, TeamMember, Activity, TournamentGroupActivities, Logs } = require("../models/models");
const { Op } = require("sequelize");

require("dotenv").config();
db = conection;

async function countTeamsInTournament(tournamentId) {
    const teamsInTournament = await TournamentTeams.findAll({
        where: {
            tournamentId: tournamentId,
        },
    })

    return teamsInTournament
}

// ROUND ROBIN SCHEDULE

function generateTeamsPerGroup(teamsCount) {
    let numGroups = 2
    let minTeamsInGroup = Math.floor(teamsCount / numGroups)
    let maxTeamsInGroup = 5

    while ( minTeamsInGroup > maxTeamsInGroup) {
        numGroups += 1
        minTeamsInGroup = Math.floor(teamsCount / numGroups)
    }
    
    let groups = []
    let groupCounter = 0
    for(let i = 0; i<numGroups; i++){
        let teamsInGroup = minTeamsInGroup
        groupCounter += teamsInGroup
        groups.push(teamsInGroup)
    }
    
    let restoTeams = teamsCount % numGroups
    for(let i=0; i<groups.length; i++) {
        if(restoTeams != 0) {
            groups[i] += 1
            restoTeams -= 1
        }
    }

    return groups
}

function ordenamientoAleatorio(a, b) { return 0.5 - Math.random() }

async function generateGroups(teams) {
    let teamsCount = teams.length
    let groupsCount = generateTeamsPerGroup(teamsCount)
    teams.sort(ordenamientoAleatorio)
    
    let groups = new Object()
    for(let i=0; i<groupsCount.length; i++) {
        groups[`Grupo ${i+1}`] = new Object()
        groups[`Grupo ${i+1}`].teams = []
        for(let j=0; j<groupsCount[i];j++) {
            let teamId = teams.pop()
            groups[`Grupo ${i+1}`].teams.push(teamId)
            const tournamentTeam = await TournamentTeams.findOne({ where: { teamId: teamId.id } })
            tournamentTeam.group = i+1
            tournamentTeam.position = j+1
            await tournamentTeam.save({ fields: ['group', 'position'] });
        }
    }
    
    return groups
}

async function findInfoFromTeam(teamId) {
    const team = await Team.findOne({ where: { id: teamId } })
    return team
}

async function createGroupActivity(equipo1, equipo2, tournament, jornada) {
    const activity = await Activity.create({
        name: equipo1.name + " vs " + equipo2.name,
        description: `Partido perteneciente a la jornada ${jornada} de torneo ${tournament.name}`,
        sport: tournament.sport,
        privacity: 1,
        max_plazas: tournament.max_players_team
    });

    const [activityTournament, created2]  = await TournamentGroupActivities.findOrCreate({
        where: {
            jornada: jornada, activityId: activity.id, tournamentId: tournament.id
        },
        defaults: {
            activityId: activity.id,
            tournamentId: tournament.id,
            jornada: jornada
        }
    });
}

async function generateMatchesImpar(group, numTeams, numJornadas, tournament) {
    let schedule = new Object()
    
    for (let i=0; i<numJornadas; i++) {
        let matches = []
        let jornada = i+1
        
        for(let j=0; j<(numTeams/2)-1; j++) {
            let match = [group[j], group[numTeams - 1 - j]]
            matches.push(match)
            await createGroupActivity(match[0], match[1], tournament, jornada)
        }

        schedule[`Jornada ${jornada}`]=(matches)
        const firstTeam = group.shift()
        group.push(firstTeam)
    }
    
    return schedule
}

async function generateMatchesPar(group, numTeams, numJornadas, tournament) {
    let schedule = new Object()
    
    for (let i=0; i<(numJornadas-1); i++) {
        let matches = []
        let jornada = i+1
        for(let j=0; j<(numTeams/2); j++) {
            let match = [group[j], group[numTeams - 1 - j]]

            if (i == numJornadas-2 && j==0) {
                let temp = match[1]
                match[1] = match[0]
                match[0] = temp
            }
            matches.push(match)
            await createGroupActivity(match[0], match[1], tournament, jornada)
        }
        
        schedule[`Jornada ${jornada}`]=(matches)
        const secondTeam = group.splice(1, 1)[0]
        group.push(secondTeam)
    }
    
    return schedule
}

async function generateMatchesInGroup(group, tournament) {
    let numTeams = group.length
    let numJornadas = numTeams
    let numMatchesPerJornada = Math.ceil(numTeams / 2)

    let schedule = numTeams % 2 == 0 
        ? await generateMatchesPar(group, numTeams, numJornadas, tournament)
        : await generateMatchesImpar(group, numTeams, numJornadas, tournament)
    
    return schedule
}

async function generateTournamentSchedule(tournamentId, tournamentTeams) {
    let groups = await generateGroups(tournamentTeams)
    let numGroups = Object.keys(groups).length
    let tournament = await Tournament.findOne({where: { id: tournamentId }})
    
    for(let i=0; i<numGroups; i++) {
        groups[`Grupo ${i+1}`].matches = {}
        groups[`Grupo ${i+1}`].matches = await generateMatchesInGroup(groups[`Grupo ${i+1}`].teams, tournament)
    }
    
    return groups;
}

const tournamentSchedule = async (req, res) => {
    try {
        const { tournamentId } = req.params;

    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Error " + err });
    }
}

const getTeamsInTournament = async (req, res) => {
    try {
        const { tournamentId } = req.params;

        const teams = await Tournament.findAll({
            attributes: [], 
            where: {
                id: tournamentId
            },
            include: {
              model: Team,
              through: {
                model: TournamentTeams
              }
            }
        });

        res.send(teams)
    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Error " + err });
    }
};

const generateTournament = async (req, res) => {
    try {
        const { tournamentId } = req.body;
        const tournament = await Tournament.findOne({
            where: {
                id: tournamentId,
            },
        }) 

        const teams = await Tournament.findAll({
            attributes: [], 
            where: {
                id: tournamentId
            },
            include: {
              model: Team,
              through: {
                attributes: [], 
                model: TournamentTeams
              }
            }
        });

        const teamsArray = []
        for(let team of teams[0].teams)
            teamsArray.push(team)

        if (teamsArray.length < tournament.min_teams)
             return res.status(403).json({ message: "No se ha cumplido el mínimo de equipos necesarios." })

        const schedule = await generateTournamentSchedule(tournamentId, teamsArray)
        res.status(201).json(schedule)
    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Error " + err });
    }
}

const createTournament = async (req, res) => {
    try {
        // Extract data from request body
        const { name, description, sport, date_start, date_end, 
            min_teams, max_teams, max_players_team, type, privacity } = req.body;

        rounds = 5

        // Create tournament in database
        const [tournament, created] = await Tournament.findOrCreate({
            where: {
                name,
            },
            defaults: {
                name, description, sport, date_start, date_end, min_teams, max_teams, max_players_team, rounds, type, privacity
            },
        });

        if (!created)
            return res.status(409).json({ message: "Tournament already exists" });

        // Send response with success message
        const logMessage = `@${req.user.nickname} ha creado el torneo de ${sport} llamado ${name}`;
        await Logs.create({ message: logMessage, category: sport });
        res.status(201).json({ message: "Tournament created successfully" });
    } catch (err) {
        console.error(err);
        res.status(500).json({ message: err });
    }
};

const getTournaments = async (req, res) => {
    try {
        var data = "";
        data = await Tournament.findAll();
        res.send(data);
    } catch (err) {
        console.log(err); //Opcional
        handleHttpError(res, "ERROR_GET_TOURNAMENT: " + err); //Si nos sirve el de por defecto que hemos establecido, no es necesario pasar el 403
    }
};

const suscribePlayerToTournament = async (req, res) => {
    let userId = req.user.id;
    let tournamentId = req.body.tournamentId;
    const tournamentInfo = await Tournament.findOne({ where: { id: tournamentId } })
    let freeTeam = tournamentInfo.name+"_free_"+tournamentInfo.id
    let sport = tournamentInfo.sport
    let max_players_team = tournamentInfo.max_players_team
    const empty = 0

    if (tournamentInfo.type != 2)
        return res.status(409).json({ message: "To this tournament cannot join players" });

    const [team, created] = await Team.findOrCreate({
        where: {
            name: freeTeam
        },
        defaults: {
            freeTeam, sport, freeTeam, max_players_team
        },
    });

    let teamId = team.teamId

    const [player, created2] = await TeamMember.findOrCreate({
        where: {
            userId: userId, teamId: teamId
        },
        defaults: {
            empty, userId, teamId
        },
    });

    if (!created2)
        return res.status(409).json({ message: "This player is already in this tournament" });

    res.send(`¡Player joined!`);
};

const subscribeTeamToTournament = async (req, res) => {
    try {
        let teamId = req.body.teamId
        let tournamentId = req.body.tournamentId
        const tournamentInfo = await Tournament.findOne({ where: { id: tournamentId } })

        if(2 >= tournamentInfo.max_teams)
            return res.status(406).json({ message: "Número maximo de equipos en el torneo sobrepasado." })
        
        let cero = 0

        const [tournamentTeam, created] = await TournamentTeams.findOrCreate({
            where: {
                teamId: teamId, tournamentId: tournamentId
            },
            defaults: {
                cero, cero, cero, cero, cero
            },
        });

        if (!created)
            return res.status(409).json({ message: "Este equipo ya está suscrito al torneo." });

        res.send(`Subscription to Tournament with success`);
    } catch(err) {
        console.log(err)
        res.send(`Error ${err}`);
    }
}

const getMyTournaments = async (req, res) => {
    try {
        const tournaments = await User.findAll({
            attributes: [], 
            where: {
                id: req.user.id
            },
            include: {
                model: Team,
                attributes: ['id'], 
                through: {
                    model: TeamMember,
                    attributes: [], 
                },
                include : {
                    model: Tournament,
                    through: {
                        model: TournamentTeams,
                        attributes: [], 
                    },
                }
            }
        });
            
        res.send(tournaments);
    } catch (err) {
        console.log(err);

        handleHttpError(res, "ERROR_GET_MY_TOURNAMENT ");
    }
};

module.exports = { 
    createTournament, 
    getTournaments, 
    suscribePlayerToTournament, 
    subscribeTeamToTournament,
    getMyTournaments, 
    generateTournament, 
    tournamentSchedule,
    getTeamsInTournament 
};